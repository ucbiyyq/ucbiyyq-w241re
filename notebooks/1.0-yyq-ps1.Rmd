---
title: "Problem Set 2"
output: html_notebook
---


```{r}
library(tidyverse)
library(data.table)
library(assertthat)
```


# 1. FE Excercise 3.6

The Clingingsmith, Khwaja, and Kremer study discussed in section 3.5 may be be used to test the sharp null hypothesis that winning the visa lottery for the pilgrimage to Mecca had no effect on the views of Pakistani Muslims toward people from other countries. Assume that the Pakistani authorities assigned visas using complete random assignment.


```{r}
# helper function to load data
q01.load.clsm <- function (f) {
    pth <- "data/raw/ps2/"
    fpth <- paste(pth,f,sep="")
    dt <- read_csv(fpth)
    
    # add a rowid to help uniquely identify each respondent
    dt <- dt %>% rowid_to_column("ID")
    
    return(dt)   
}
q01.clsm <- q01.load.clsm("Clingingsmith.2009.csv")


```

Each row of data represents a single respondent. The view_xyz fields are the changes in the views of the respondent towards peoples from other countries.

```{r}
q01.clsm %>% head()

# checks that we loaded the right csv
assert_that(q01.clsm %>% count() == 958)

# checks that the views columns is the rowSum of the other views columns
temp <- q01.clsm %>% 
    select(starts_with("views_")) %>% 
    rowSums()
assert_that(
    (temp == q01.clsm$views) %>% unique() == TRUE
)
```


## 1.a.

Conduct 10,000 simulated random assignments under the sharp null hypothesis

Under sharp null hypothesis, we can assume that the assignment to treatment has zero treatment effect on any of the units of treatment. So, we don't have to change the values of the views in either the potential outcome to treatment, D==1, or the potential outcome to control, D==0.

We are using simple random assignment, so basically flipping a fair coin to determine if a respondent is assigned to treatment (got visa) or control (did not get visa).

Note, we are calculating the ATE for every view. 


```{r}
# when given the clsm data, calculates the ATE for every view
q01.calc.ates <- function (dt) {
    dt <- dt %>% 
        select(success, starts_with("view")) %>% 
        group_by(success) %>% 
        summarize_all(funs(mean))

    dt <- dt %>% 
        gather(starts_with("views"), key = "vw", value = "val") %>% 
        spread(key = success, value = val)
    
    dt <- dt %>% 
        mutate(ate = `1` - `0`) %>% 
        select(vw, ate)
    
    return(dt)
}
q01.clsm.ates <- q01.calc.ates(q01.clsm)
```


```{r}
# given the clsm data, runs n number of simulations
q01.sim.n <- function(dt, n) {
    
    # helper function to sim assignment to treatment by simple random assignment
    simpl.rand.assign <- function (xt) {
        # simple random assignment to treatment or control
        # ... reuses the success variable because 
        # ... ... that is the treatment indicator variable expected by the clsm.ates() function
        xt <- xt %>% 
            select(starts_with("view")) %>% 
            mutate(success = rbinom(nrow(xt),1,.5))
        return(xt)
    }
    
    set.seed(232354)

    # creates a nested table of clsm data, one row per sim    
    dt <- dt %>% 
        select(success, starts_with("views"))
    
    sims <- seq(1,n,1) %>% 
        tibble() %>% 
        set_names(nm = "sim.id")
    
    sims <- sims %>% 
        crossing(dt) %>%
        group_by(sim.id) %>% 
        nest(.key="sim.data")
    
    # runs each sim data through simple random assignments
    sims <- sims %>% 
        mutate(sim.data = map(sim.data, simpl.rand.assign))
    
    # runs each sim data through the ate calculations
    sims <- sims %>%
        mutate(sim.ates = map(sim.data, q01.calc.ates))
    
    return(sims)
}
# q01.sims <- q01.sim.n(q01.clsm, 1000)
```



```{r}
# given simulation results, produces an unnested table of ATEs for each view and sim.id
# ... useful for future calculations
q01.simpl <- function (dt) {
    res <- dt %>% 
        select(sim.id, sim.ates) %>% 
        unnest()
    return(res)
}
# q01.sim.ates <- q01.simpl(q01.sims)
q01.sim.ates <- q01.clsm %>% q01.sim.n(1000) %>% q01.simpl()
```


```{r}
# checks that each simulation has the same number of ATEs as the actual ATEs
assert_that(
    q01.sim.ates %>% count(sim.id) %>% .$n %>% unique() == q01.clsm.ates %>% nrow()
)
```




## 1.b. 

How many of the simulated random assignments generate an estimated ATE that is at least as large as
the actual estimate of the ATE?

Note, we are still calculating this for all ATEs of each view

```{r}
q01.count.gte <- function (s.ates, c.ates) {
    c.ates <- q01.clsm.ates
    s.ates <- q01.sim.ates
    
    # joins the actual ATEs to the simulated ATEs, then counts gte
    res <- inner_join(c.ates, s.ates, by="vw", suffix = c(".clsm", ".sim")) %>%
        mutate( gte = (ate.sim >= ate.clsm) ) %>% 
        count(vw, gte) %>% 
        spread(key = gte, value = n, fill = 0) %>% 
        rename("sim.gte.clsm" = `TRUE`, "sim.lt.clsm" = `FALSE`)
    
    return(res)
}
temp <- q01.sim.ates %>% q01.count.gte(q01.clsm.ates)
```

